#!/usr/bin/env python3

import sqlite3
import subprocess
import os
import sys
import pandas as pd
from gurobipy import *
import pprint
import itertools

class score_with_gurobi():
    """
    Class for determining best combinations of motif residues using Rosetta's feature reporter system
    """
    def __init__(self, user_defined_dir, config_dict=None):
        self.user_defined_dir = user_defined_dir
        self.resources_dir = os.path.join(os.path.dirname(__file__), '..', 'Additional_Files')
        self.user_config = config_dict

    def complete_everything(self):
        pass

    def generate_feature_reporter_db(self):
        """
        Generates a SQLITE3 database with all necessary two-body residue scores
        :return: 
        """

        rosettascripts_path = os.path.join(self.user_config['Rosetta_path'], 'main/source/bin/rosetta_scripts.{}'.format(self.user_config['Rosetta_compiler']))

        run_feature_reporter = subprocess.Popen([rosettascripts_path, # UPDATE
                                                 '-parser:protocol',
                                                 os.path.join(self.resources_dir, 'RosettaScripts', 'Two_body_residue_feature_reporter.xml'),
                                                 '-out:nooutput',
                                                 '-parser:script_vars',
                                                 'target={}'.format(self.user_defined_dir),
                                                 '-l',
                                                 './{}/Motifs/Residue_Ligand_Interactions/Single_Poses/single_pose_list.txt'.format(self.user_defined_dir),
                                                 '-extra_res_fa',
                                                 './{}/Inputs/Rosetta_Inputs/{}.params'.format(self.user_defined_dir, self.user_defined_dir)
                                                 ])
        run_feature_reporter.wait()

    def consolidate_scores_better(self):
        """
        Consolidates two-body terms into single score for two-body interactions
        Dumps these values into a new table in the source SQLITE3 database generated by the feature reporter
        
        The new plan:
        create sqlite table with [fa_atr, fa_elec, hbond_sc, hbond_bb_sc] from residue_scores_2b
        create sqlite table with [fa_rep] * 0.55 from residue_scores_2b
        merge tables with create new table sum(score_value) group by (batch_id, struct_id, resNum1, resNum2)
        :return: 
        """
        connection = sqlite3.connect('./{}/two_body_terms.db'.format(self.user_defined_dir))
        cursor = connection.cursor()

        # Generate new table with residue-index mappings from .csv
        df = pd.read_csv('./{}/Motifs/Residue_Ligand_Interactions/Single_Poses/residue_index_mapping.csv'.format(
            self.user_defined_dir), index_col=0)
        df.to_sql('residue_index_mapping', con=connection, if_exists='replace')

        cursor.execute(
            """CREATE TABLE relevant_2b_scores AS
            SELECT residue_scores_2b.batch_id, residue_scores_2b.struct_id, residue_scores_2b.resNum1,
            residue_scores_2b.resNum2, score_types.score_type_name, residue_scores_2b.score_value from residue_scores_2b
            left join score_types on residue_scores_2b.score_type_id == score_types.score_type_id where 
            (score_types.score_type_name = 'fa_atr' or
            score_types.score_type_name = 'fa_elec' or
            score_types.score_type_name = 'hbond_sc' or
            score_types.score_type_name = 'hbond_bb_sc') 
            UNION 
            SELECT residue_scores_2b.batch_id, residue_scores_2b.struct_id, residue_scores_2b.resNum1,
            residue_scores_2b.resNum2, score_types.score_type_name, (residue_scores_2b.score_value * 0.55) from residue_scores_2b
            left join score_types on residue_scores_2b.score_type_id == score_types.score_type_id where 
            (score_types.score_type_name = 'fa_rep')
            """
        )

    def do_gurobi_things(self):
        # Generate gurobi input table/csv
        connection = sqlite3.connect('./{}/two_body_terms.db'.format(self.user_defined_dir))
        cursor = connection.cursor()

        residue_table = pd.read_sql_query("SELECT * from residues", connection)
        score_table = pd.read_sql_query(
            """
            SELECT struct_id, resNum1, resNum2, 
            CASE
            WHEN round(sum(score_value), 4) >= 0 THEN 1
            ELSE round(sum(score_value), 4)
            END 
            as score_total from relevant_2b_scores group by struct_id, resNum1, resNum2;
            """, connection)

        for struct_id, table in residue_table.groupby(['struct_id']):

            #######################
            # Solve for solutions #
            #######################

            # Set up model
            residue_interactions = Model("residue_interactions")
            MIP_var_dict = {}

            # Add ligand
            MIP_var_dict[float(1.0)] = residue_interactions.addVar(vtype=GRB.BINARY, name=str(1))

            # Only add residues to Model if ligand-residue interaction energy is less than X
            ligand_residue_scores = score_table.groupby(['struct_id', 'resNum1']).get_group((struct_id, 1))
            for index, row in ligand_residue_scores.iterrows():
                if row['score_total'] <= -0.75:
                    MIP_var_dict[row['resNum2']] = residue_interactions.addVar(vtype=GRB.BINARY, name=str(row['resNum2']))

            # List of residue indcies used in Model
            MIP_residx_list = list(MIP_var_dict.keys())

            # Set up dict with pairwise scores
            score_dict = {}
            relevant_scores = score_table.groupby(['struct_id']).get_group(struct_id)
            for index, row in relevant_scores.iterrows():
                if all([row['resNum1'] in MIP_residx_list, row['resNum2'] in MIP_residx_list]):
                    score_dict[(row['resNum1'], row['resNum2'])] = row['score_total']

            # Set objective function
            two_body_interactions = [MIP_var_dict[key[0]] * MIP_var_dict[key[1]] * value for key, value in score_dict.items()]
            residue_interactions.setObjective(quicksum(two_body_interactions), GRB.MINIMIZE)

            ###################
            # Add constraints #
            ###################

            # Always include ligand (residue 1)
            residue_interactions.addConstr(MIP_var_dict[float(1)] == 1)

            # Number of residues in a binding motif (includes ligand)
            residue_interactions.addConstr(quicksum(var for var in MIP_var_dict.values()) == 7)

            # todo: update this to use score_dict
            # Residues cannot be a solution if two-body interaction energy is above X
            current_struct_scores = score_table.groupby(['struct_id']).get_group(struct_id)
            for index, row in current_struct_scores.iterrows():
                if row['score_total'] >= 0 and all([row['resNum1'] in MIP_residx_list, row['resNum2'] in MIP_residx_list]):
                    residue_interactions.addConstr(MIP_var_dict[int(row['resNum1'])] + MIP_var_dict[int(row['resNum2'])] <= 1)

            # Set Parameters
            residue_interactions.Params.PoolSolutions = 10000
            residue_interactions.Params.PoolGap = 0.2
            residue_interactions.Params.PoolSearchMode = 2

            residue_interactions.Params.MIPFocus = 3
            residue_interactions.Params.Heuristics = 0.1

            # Optimize
            residue_interactions.optimize()

            ######################
            # Retrieve solutions #
            ######################

            # Get residue-index mapping for current conformer
            index_mapping = pd.read_sql_query("SELECT * from residue_index_mapping WHERE struct_id = {}".format(struct_id), connection, index_col='residue_index')

            results_list = []

            for i in range(residue_interactions.SolCount):
                residue_interactions.setParam(GRB.Param.SolutionNumber, i)

                res_index_tuple = [int(float(value.VarName)) for index, value in enumerate(residue_interactions.getVars()) if int(value.Xn) == 1]

                source_pdb_list = [index_mapping.loc[idx, 'source_pdb'] for idx in res_index_tuple if idx != 1]
                print('Residue Indicies: {}'.format(res_index_tuple))
                # print('Non-Ideal Obj: {}'.format(residue_interactions.PoolObjVal))

                # Janky method to get values for non-ideal solutions since I can't get Model.PoolObjVal to work...
                solution_residue_pairs = [a for a in itertools.combinations(res_index_tuple, 2)]
                non_ideal_solution = sum(value for key, value in score_dict.items() if key in solution_residue_pairs)
                print('Non-Ideal Obj: {}'.format(non_ideal_solution))

                results_list.append({'Residue_indicies': res_index_tuple,
                                     'Obj_score': non_ideal_solution})

            df = pd.DataFrame(results_list)
            df.to_csv('Gurobi_results-{0}-{1}.csv'.format(os.path.basename(os.path.normpath(self.user_defined_dir)), struct_id))
