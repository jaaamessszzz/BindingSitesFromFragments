#!/usr/bin/env python3

import os
import re
import json
import prody
import pandas as pd

from ..motifs import Generate_Fuzzball_using_PyRosetta
from ..utils import pdb_check

def assemble(args):
    """
    Build a fuzzball using the best scoring side chain interactions with the defined ligand

    Usage:
      bsff assemble <user_defined_dir> [options]
      bsff assemble <user_defined_dir> iteration <gurobi_constraints_csv> [options]

    Arguments:
      <user_defined_dir>              Path to project root directory
      iteration                       Add motif residues from a previous iteration
      <gurobi_constraints_csv>        Path to Gurobi solutions .csv generated by `prepare_match_iterations.py`

    Options:
      --add_user_defined_motifs       Add any motif residues defined under `Inputs/Defined_Interactions` to the fuzzball
      --fuzzball_limit=<fuzz_limit>   Limit to the number of motif residues to be added to the fuzzball
      --hbond_limit=<hb_limit>        Limit to the number of hydrogen bonding residues to be added for each hydrogen
                                      bond donor/acceptor on the ligand
      -i=<index>, --index=<index>     Only generate fuzzballs with specified index
    """
    # Dump current iteration of fuzzballs into own directory
    fuzzball_dir = os.path.join(args['<user_defined_dir>'], 'Fuzzballs')
    print([x for x in os.listdir(fuzzball_dir)])
    iteration = len([x for x in os.listdir(fuzzball_dir) if os.path.isdir(os.path.join(fuzzball_dir, x))])
    current_iteration_dir = os.path.join(fuzzball_dir, f'Iteration-{iteration}')

    # Make directory for Fuzzballs
    os.makedirs(current_iteration_dir, exist_ok=True)

    derp = Generate_Fuzzball_using_PyRosetta(args['<user_defined_dir>'], current_iteration_dir)

    # Map fuzzball iteration composition to struct_id
    if args['iteration']:

        # Map fuzzball composition to struct_id
        struct_id_list = list()
        struct_id_count = 1

        # Track processed constraints
        processed_constraints = set()

        # Find previous iteration Fuzzball dir
        previous_iteration = os.path.join(fuzzball_dir, f'Iteration-{iteration - 1}')
        if not os.path.exists(previous_iteration):
            raise SystemExit(f'Previous iteration directory {previous_iteration} does not exist!')

        iteration_df = pd.read_csv(args['<gurobi_constraints_csv>'], index_col=False)
        for index, row in iteration_df.iterrows():
            if row['constraint'] not in processed_constraints:

                def indicies_from_filename(file):
                    """[2, 3, 4] from 38E_0001-1_2_3_4"""
                    split_filename = file.split('-')[1].split('_')
                    return [] if len(split_filename) == 1 else split_filename[1:]

                # Get conformer and indicies for current constraint
                fuzzball_constraint = row['constraint']
                fuzzball_conformer = fuzzball_constraint.split('-')[0]
                fuzzball_constraint_indicies = indicies_from_filename(fuzzball_constraint)

                # Get fuzzball from previous iteration
                fuzzball_index = fuzzball_constraint.split('-')[2]
                previous_iteration_fuzzballs = [fuzz for fuzz in pdb_check(previous_iteration, base_only=True) if fuzzball_index in fuzz.split('-')]
                print(previous_iteration_fuzzballs)

                assert len(previous_iteration_fuzzballs) == 1
                previous_iteration_fuzzball_file = previous_iteration_fuzzballs[0].split('.')[0]
                previous_iteration_fuzzball_indicies = indicies_from_filename(previous_iteration_fuzzball_file)

                # Pull residues from previous iteration fuzzball
                previous_iteration_fuzzball = prody.loadAtoms(os.path.join(previous_iteration, f'{previous_iteration_fuzzball_file}.ag.npz'))

                # Pull residues from previous iteration fuzzball
                previous_iteration_residues = previous_iteration_fuzzball.select('defined 1')
                current_iteration_residues_indicies = fuzzball_constraint_indicies[len(previous_iteration_fuzzball_indicies):]
                current_iteration_residues = previous_iteration_fuzzball.select(f'resnum {" ".join(current_iteration_residues_indicies)}')

                print(previous_iteration_residues)
                print(current_iteration_residues_indicies)

                if len(current_iteration_residues_indicies) > 0:
                    # Low-effort catch where user-defined residues are 'defined' (current_iteration_residues) in iteration-0 match cycle
                    if iteration > 1:
                        current_defined_residues = previous_iteration_residues + current_iteration_residues
                    else:
                        current_defined_residues = current_iteration_residues
                else:
                    current_defined_residues = previous_iteration_residues

                print(fuzzball_constraint)
                print(current_defined_residues)

                # Add residues to current fuzzball as defined residues
                fuzzball_path = derp.assemble_fuzzball(fuzzball_conformer, iteration=current_defined_residues, iteration_name=fuzzball_constraint,
                                                       iteration_index=iteration, fuzzball_index=struct_id_count)

                # Add mapping to struct_id_list
                struct_id_list.append({struct_id_count: row['constraint']})
                struct_id_count += 1

                # Add fuzzball to FeatureReporter list
                with open(os.path.join(current_iteration_dir, 'fuzzball_list.txt'), 'a') as fuzzy_fuzz:
                    fuzzy_fuzz.write(f'{fuzzball_path}\n')

                # Add to processed
                processed_constraints.add(row['constraint'])

        # Write mapping
        mapping_df = pd.DataFrame(struct_id_list)
        mapping_df.to_csv(f'Iteration-{iteration}.csv')

    else:
        with open(os.path.join(current_iteration_dir, 'fuzzball_list.txt'), 'w') as fuzzy_fuzz:
            for conformer in pdb_check(derp.rosetta_inputs, base_only=True, conformer_check=True):
                conformer_name = conformer.split('.')[0]
                fuzzball_path = derp.assemble_fuzzball(conformer_name, iteration=iteration)
                fuzzy_fuzz.write(f'{fuzzball_path}\n')