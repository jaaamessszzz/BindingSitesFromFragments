#!/usr/bin/env python3

import os
import sys
import copy
import json
import math
import pickle
from pprint import pprint

import prody
import pandas as pd

from .motifs import Generate_Constraints
from .utils import *

import pyrosetta
from pyrosetta import rosetta

def generate_constrained_backrub_ensemble(raw_match_path, matcher_constraint):
    """
    Generate a backrub ensemble around the hypothetical binding site with matcher constraints applied
    :return:
    :param raw_match_path: path to raw match output
    :param matcher_constraint: constraint file used to find match
    """
    pass


def parse_matcher_remarks(match_path):
    """
    Parse matcher remarks to return match positions
    :param match_pose: pose with matcher remark header
    :return:
    """

    motif_resnums = list()
    with open(match_path, 'r') as match:
        for line in match:
            split_remark = line.split()

            # Only parse matcher remarks
            if split_remark[0] == 'REMARK':
                if all([split_remark[:4] == ['REMARK', '666', 'MATCH', 'TEMPLATE'], split_remark[7:9] == ['MATCH', 'MOTIF']]):
                    motif_resnums.append(int(split_remark[11]))

    return motif_resnums

def generate_fuzzball_contact_rotamersets(ligand_conformer_path, match_path, match_pose, sfxn, match_residue_map,
                                          flag_special_rot=True, custom_taskop=None, rotset_limit=200,
                                          contact_method='RMSD', RMSD_limit=1.5, apply_minimization=False,
                                          dump_rotamerset_pdb=False, report_stats=False):
    """
    Generate rotamers that recapitulate observed fuzzball contacts for each position in a nucleated match
    :param ligand_conformer_path: path to ligand generated by molfile_to_params.py
    :param flag_special_rot: If true, flag rotamers as SPECIAL_ROT variants
    :param custom_taskop: list of task operations to apply to the PackerTask used to generate rotamers

    :return:
    """

    sfxn_weights = sfxn.weights()
    conformer_resnum = match_pose.size()  # Assumes single ligand appended to end of sequence

    if contact_method not in ['RMSD', 'matcher']:
        raise Exception('Contact method needs to be one of the following: "RMSD", "matcher"')

    # --- Find and store viable rotamers --- #

    viable_rotamers = dict()
    rotamer_stats = dict()

    # Setting things up is going to mess up the match pose, so use a clone
    match_pose_clone = match_pose.clone()
    sfxn(match_pose_clone)

    # --- Transform match pose clone onto fuzzball conformer --- #
    """Required for contact coordsets to make sense"""

    # Get ligand from match, always last residue
    # todo: select chain X, ligand is always chain X
    match_pose_size = match_pose_clone.size()
    match_ligand = match_pose_clone.residue(match_pose_size)

    # Get match positions if they exist
    motif_resnums = list()
    with open(match_path, 'r') as my_match:
        for line in my_match:
            if line.startswith('REMARK 666 MATCH TEMPLATE'):
                motif_resnums.append(int(line.split()[11]))

    motif_and_ligand_resnums = motif_resnums + [conformer_resnum]

    # Keep track of match positions and compatible residue identites
    # match_residue_map = {position: dict() for position in range(1, match_pose.size())}  # Assumes one ligand appended to end of sequence

    # Import conformer from pose
    fuzzball_ligand_pose = rosetta.core.pose.Pose()
    rosetta.core.import_pose.pose_from_file(fuzzball_ligand_pose, ligand_conformer_path)
    fuzzball_ligand = fuzzball_ligand_pose.residue(1)

    # Calculate rotation/translation by hand using first three atoms of ligand
    mobile_match = rosetta.numeric.xyzTransform_double_t(match_ligand.xyz(1), match_ligand.xyz(2), match_ligand.xyz(3))
    mobile_match_inverse = mobile_match.inverse()
    target_fuzzball = rosetta.numeric.xyzTransform_double_t(fuzzball_ligand.xyz(1), fuzzball_ligand.xyz(2), fuzzball_ligand.xyz(3))

    ligand_rotation = target_fuzzball.R * mobile_match_inverse.R
    ligand_translation = target_fuzzball.R * mobile_match_inverse.t + target_fuzzball.t

    # Apply transformation
    match_pose_clone.apply_transform_Rx_plus_v(ligand_rotation, ligand_translation)
    match_pose_clone_ligand = match_pose_clone.residue(match_pose_size).clone()

    # --- All other operations --- #

    # Mutate all non-motif residues within 10A from ligand to ALA, interferes with RotamerSet generation
    ligand_residue_selector = rosetta.core.select.residue_selector.ChainSelector('X')
    neighborhood_selector = rosetta.core.select.residue_selector.NeighborhoodResidueSelector(ligand_residue_selector, 10, False)
    neighborhood_selector_bool = neighborhood_selector.apply(match_pose_clone)
    neighborhood_residues_resnums = rosetta.core.select.get_residues_from_subset(neighborhood_selector_bool)
    positions_to_consider = list(set(neighborhood_residues_resnums) - set(motif_and_ligand_resnums))

    mutate = rosetta.protocols.simple_moves.MutateResidue()
    mutate.set_res_name('ALA')

    for position in positions_to_consider:
        if match_pose_clone.residue(position).name3() not in ['GLY', 'PRO'] and 'disulfide' not in match_pose_clone.residue(position).name():
            mutate.set_target(position)
            mutate.apply(match_pose_clone)

    # Build RotamerSets for each extrachi/sample level
    if dump_rotamerset_pdb:
        all_rotamersets = rosetta.core.pack.rotamer_set.RotamerSetsFactory.create_rotamer_sets(match_pose_clone)
        task_factory = rosetta.core.pack.task.TaskFactory()

        # NATRO positions TaskOp
        rotamer_candidates_rs = rosetta.core.select.residue_selector.ResidueIndexSelector(','.join([str(i) for i in match_residue_map.keys()]))
        natro_rs = rosetta.core.select.residue_selector.NotResidueSelector(rotamer_candidates_rs)
        natro_op = rosetta.core.pack.task.operation.OperateOnResidueSubset(
            rosetta.core.pack.task.operation.PreventRepackingRLT(), natro_rs)
        task_factory.push_back(natro_op)

        rotamersets_packer_task = task_factory.create_task_and_apply_taskoperations(match_pose_clone)

        all_rotamersets.set_task(rotamersets_packer_task)

    # Remove ligand from match_pose_clone before generating rotamers!!!
    match_pose_clone_apo = match_pose_clone.clone()
    match_pose_clone_apo.conformation_ptr().delete_residue_slow(match_pose_size)

    # Generate rotamers at each position
    for position in match_residue_map.keys():

        # Prepare minimization
        if apply_minimization:
            motif_movemap = rosetta.core.kinematics.MoveMap()
            motif_movemap.set_chi(position, True)

            minimize_motif = rosetta.protocols.minimization_packing.MinMover()
            minimize_motif.movemap(motif_movemap)

        # Prepare infrastructure
        rotamer_stats[position] = dict()

        if dump_rotamerset_pdb:
            current_rotamerset = rosetta.core.pack.rotamer_set.RotamerSetFactory.create_rotamer_set(match_pose_clone)

        # Keep rotamers that are compatible with minimal binding motif
        for contact_residue in match_residue_map[position]:

            # print(f'Considering position {position}: {contact_residue}')
            position_rotamer_list = list()
            possible_contact_geometries = match_residue_map[position][contact_residue]

            # --- Prepare viable rotamers for each position --- #

            # Define packertask using neighborhood_selector
            packer_task = rosetta.core.pack.task.TaskFactory.create_packer_task(match_pose_clone_apo)
            packer_task.initialize_from_command_line()

            # Get boolean vector for packable positions and apply to packer task
            packable_positions = rosetta.utility.vector1_bool()
            packable_position_list = [True if i == position else False for i in range(1, match_pose_clone_apo.size())]
            for bool_value in packable_position_list:
                packable_positions.append(bool_value)
            packer_task.restrict_to_residues(packable_positions)

            # Only build rotamers for residues with Hbond donors/acceptors
            restrict_CAAs = rosetta.core.pack.task.operation.RestrictAbsentCanonicalAAS(position, rosetta.utility.vector1_bool(20))
            restrict_CAAs.keep_aas(contact_residue)
            restrict_CAAs.apply(match_pose_clone_apo, packer_task)

            packer_neighbor_graph = rosetta.core.pack.create_packer_graph(match_pose_clone_apo, sfxn, packer_task)

            match_rotamer_set = rosetta.core.pack.rotamer_set.RotamerSetFactory.create_rotamer_set(match_pose_clone_apo)
            match_rotamer_set.set_resid(position)
            match_rotamer_set.build_rotamers(match_pose_clone_apo, sfxn, packer_task, packer_neighbor_graph, use_neighbor_context=False)

            if match_rotamer_set.num_rotamers() <= 1 and match_rotamer_set.rotamer(1).name1() != contact_residue:
                continue

            print(f'Position {position} ResidueType {contact_residue} - comparing {match_rotamer_set.num_rotamers()} rotamers against {len(possible_contact_geometries)} contact modes')

            rotamer_stats[position][contact_residue] = dict()
            rotamer_stats[position][contact_residue]['num_rotamers'] = match_rotamer_set.num_rotamers()
            rotamer_info = list()
            rotamers_accepted = 0

            # --- Evaluate Rotamers --- #

            for rotamer in range(1, match_rotamer_set.num_rotamers() + 1):

                # Place residue before applying to pose!!!!
                # Rotamers need to be transformed back onto the backbone of the input pdb!!!
                trail_rotamer = match_rotamer_set.rotamer(rotamer)
                trail_rotamer.place(match_pose_clone.residue(position), match_pose_clone.conformation_ptr())
                match_pose_clone.replace_residue(position, trail_rotamer, False)
                pose_trial_rotamer = match_pose_clone.residue(position)

                # Evaluate RMSD to possible_contact_geometries
                contact_RMSDs = list()
                dof_errors = list()
                sad_atom_in_rotamer = False

                for contact_mode in possible_contact_geometries:

                    # REFERENCE: contact_info = [current_motif_coord_list, [float(a) for a in dof_tuple], constraint_atoms_dict['residue']['atom_names'], constraint_atoms_dict['ligand']['atom_names']]
                    current_motif_coord_list = contact_mode[0]
                    contact_dofs = contact_mode[1]
                    residue_matchatoms = contact_mode[2]
                    ligand_matchatoms = contact_mode[3]

                    # Skip rotamer if contact is mediated by a backbone atom...
                    if residue_matchatoms[0] in ['C', 'CA', 'N', 'O']:
                        continue

                    # Get contact atom coords using atom names
                    try:
                        rotamer_contact_coords = [list(match_pose_clone.residue(position).xyz(atom)) for atom in residue_matchatoms]

                        # If distance is off, don't even bother...
                        residue_contactatom = pose_trial_rotamer.xyz(residue_matchatoms[0])
                        ligand_contactatom = match_pose_clone_ligand.xyz(ligand_matchatoms[0])
                        atom_displacement = ligand_contactatom - residue_contactatom
                        if atom_displacement.norm() > 4:
                            # print(f'Contact is {atom_displacement.norm()}A, continuing...')
                            continue

                        residue_atomid_list = [pose_trial_rotamer.xyz(atom) for atom in residue_matchatoms]
                        ligand_atomid_list = [match_pose_clone_ligand.xyz(atom) for atom in ligand_matchatoms]

                        # Res1 - ligand, Res2 - residue

                        # 'angle_A' is the angle Res1:Atom2 - Res1:Atom1 - Res2:Atom1
                        angle_A = rosetta.numeric.angle_degrees_double(ligand_atomid_list[1], ligand_atomid_list[0], residue_atomid_list[0])
                        # 'angle_B' is the angle Res1:Atom1 - Res2:Atom1 - Res2:Atom2
                        angle_B = rosetta.numeric.angle_degrees_double(ligand_atomid_list[0], residue_atomid_list[0], residue_atomid_list[1])
                        # 'torsion_A' is the dihedral Res1:Atom3 - Res1:Atom2 - Res1:Atom1 - Res2:Atom1
                        torsion_A = rosetta.numeric.dihedral_degrees_double(ligand_atomid_list[2], ligand_atomid_list[1], ligand_atomid_list[0], residue_atomid_list[0])
                        # 'torsion_AB' is the dihedral Res1:Atom2 - Res1:Atom1 - Res2:Atom1 - Res2:Atom2
                        torsion_AB = rosetta.numeric.dihedral_degrees_double(ligand_atomid_list[1], ligand_atomid_list[0], residue_atomid_list[0], residue_atomid_list[1])
                        # 'torsion_B' is the dihedral Res1:Atom1 - Res2:Atom1 - Res2:Atom2 - Res2:Atom3
                        torsion_B = rosetta.numeric.dihedral_degrees_double(ligand_atomid_list[0], residue_atomid_list[0], residue_atomid_list[1], residue_atomid_list[2])

                        rotamer_dofs = [angle_A, angle_B, torsion_A, torsion_AB, torsion_B]

                    except Exception as e:
                        print(e, residue_matchatoms, ligand_matchatoms)
                        # print(f'Skipping {contact_mode[0]}: contains sad atom.')
                        sad_atom_in_rotamer = True
                        break

                    # todo: Edge condition at 0/360...
                    dof_difference_list = [abs(ideal - measured) for ideal, measured in zip(contact_dofs[1:], rotamer_dofs)]
                    # print('contact_dofs:', contact_dofs)
                    # print('rotamer_dofs:', rotamer_dofs)
                    # print('DOF DIFFERENCE LIST:', dof_difference_list)
                    dof_errors.append(max(dof_difference_list))

                    contact_RMSDs.append(prody.calcRMSD(np.asarray(current_motif_coord_list), np.asarray(rotamer_contact_coords)))

                if len(dof_errors) == 0:
                    continue

                if sad_atom_in_rotamer:
                    continue

                # Continue if current rotamer does not have <{RMSD_limit}A RMSD with any contact mode
                if contact_method == 'RMSD' and min(contact_RMSDs, default=666) > RMSD_limit:
                    rotamer_info.append((contact_RMSDs, None, None))
                    continue

                # Only continue if a contact mode exists where max angle/torsion DOF error < 10 degrees
                if contact_method == 'matcher' and min(dof_errors) > 15:
                    continue

                # Apply minimization to rotamer-ligand interaction before deciding to accept
                if apply_minimization:
                    minimize_motif.apply(match_pose_clone)

                # Evaluate possible clashes (fa_rep) with motif residues and ligand
                sfxn(match_pose_clone)
                edges = match_pose_clone.energies().energy_graph()

                motif_fa_rep = list()
                for motif in motif_and_ligand_resnums:
                    current_edge = edges.find_energy_edge(position, motif)
                    if current_edge is not None:
                        current_edge.fill_energy_map()
                        motif_fa_rep.append(current_edge[rosetta.core.scoring.fa_rep])

                # Get score for current rotamer against ligand
                current_edge = edges.find_energy_edge(position, conformer_resnum)
                rotamer_ligand_reu = current_edge.dot(sfxn_weights) if current_edge is not None else 0

                if all([min(motif_fa_rep, default=666) < 20, rotamer_ligand_reu <= 20]):

                    if flag_special_rot:

                        current_rsd_type_ptr = match_pose_clone.residue_type_ptr(position)
                        new_rsd_type_mutable = rosetta.core.chemical.MutableResidueType(current_rsd_type_ptr)
                        new_rsd_type_mutable.add_variant_type(rosetta.core.chemical.SPECIAL_ROT)
                        new_rsd_type = rosetta.core.chemical.ResidueType.make(new_rsd_type_mutable)
                        rosetta.core.pose.replace_pose_residue_copying_existing_coordinates(match_pose_clone, position, new_rsd_type)

                    # Place residue before applying to pose!!!!
                    # Rotamers need to be transformed back onto the backbone of the input pdb!!!
                    new_rotamer = match_pose_clone.residue(position).clone()
                    new_rotamer.place(match_pose.residue(position), match_pose.conformation_ptr())

                    position_rotamer_list.append((rotamer_ligand_reu, new_rotamer))
                    rotamers_accepted += 1

                    if dump_rotamerset_pdb:
                        current_rotamerset.add_rotamer(new_rotamer)

                rotamer_info.append((max(dof_errors), max(motif_fa_rep, default=0), rotamer_ligand_reu))

            print(f'{rotamers_accepted} of {match_rotamer_set.num_rotamers()} rotamers accepted')
            rotamer_stats[position][contact_residue]['rotamer_info'] = rotamer_info
            rotamer_stats[position][contact_residue]['rotamers_accepted'] = rotamers_accepted

            if len(position_rotamer_list) > 0:
                position_rotamer_list_selected = sorted(position_rotamer_list, key=lambda x: x[0])[:rotset_limit]
                position_rotamer_list = [rot[1] for rot in position_rotamer_list_selected]
                if position not in viable_rotamers.keys():
                    viable_rotamers[position] = dict()
                viable_rotamers[position][contact_residue] = position_rotamer_list

        if dump_rotamerset_pdb:
            current_moltresid = all_rotamersets.resid_2_moltenres(position)
            all_rotamersets.set_explicit_rotamers(current_moltresid, current_rotamerset)

    if dump_rotamerset_pdb:
        current_extrachi = len([rosetta.basic.options.get_boolean_option(f'packing:ex{i}') for i in range(1,5) if rosetta.basic.options.get_boolean_option(f'packing:ex{i}') is True])
        current_sample_level = rosetta.basic.options.get_integer_option(f'packing:ex{current_extrachi}:level')

        if current_extrachi <= 2 and current_sample_level <= 3:
            match_name = os.path.normpath(os.path.basename(match_path))

            # todo: figure out why this doesn't work... problem with CONECT records...
            # all_rotamersets.dump_pdb(match_pose_clone, f"{match_name.split('.')[0]}-extrachi_{current_extrachi}-sampling_{current_sample_level}.pdb")

            all_rotamers_pose = pyrosetta.pose_from_sequence('A')

            for position in match_residue_map.keys():
                position_rotset = all_rotamersets.rotamer_set_for_residue(position)
                for rot in range(1, position_rotset.num_rotamers() + 1):
                    all_rotamers_pose.append_residue_by_jump(position_rotset.rotamer(rot), 1)
            all_rotamers_pose.dump_pdb(f"{match_name.split('.')[0]}-extrachi_{current_extrachi}-sampling_{current_sample_level}.pdb")

    if report_stats:
        return viable_rotamers, rotamer_stats
    else:
        return viable_rotamers


def fuzzball_composition_design(ligand_conformer_path, match_path, match_residue_map, design_config_json, params_path,
                                designdir='Designs', nstruct=1, special_rot_weight=-5, use_complementary_rotsets=True,
                                rotset_limit=200, apply_minimization=False):
    """
    Perform design using Vikram's AA_Composition score term, biasing toward rotamers that recapitulate contacts
    observed in the iteration fuzzball.
    :return:
    """

    # --- Initiate PyRosetta and Score Function -- #

    my_options = [f"-extra_res_fa {params_path}",
                  "-mute core.conformation core.chemical core.pack.task",
                  '-ex1 -ex2 -extrachi_cutoff 0']
    pyrosetta.init(options=' '.join(my_options))

    # Create match pose
    match_pose = rosetta.core.pose.Pose()
    rosetta.core.import_pose.pose_from_file(match_pose, os.path.join(os.getcwd(), match_path))

    # Normal scorefunction for generating rotamers
    sfxn = rosetta.core.scoring.get_score_function()

    # Add defined_rotamer scoreterm
    sfxn.set_weight(rosetta.core.scoring.special_rot, special_rot_weight)

    # --- Set up Annealer for design --- #

    # Load design json
    design_json_info = json.load(open(design_config_json, 'r'))

    # Load viable scaffold positions and corresponding residue types
    # todo: make sure backrub ensemble structures also have matcher remarks added
    match_residue_map = pickle.load(open(match_residue_map, 'rb'))

    # todo: write "layer selector" for two contact layer deep design shell

    # --- Residue Selectors --- #

    # Ligand
    matched_ligand_rs = rosetta.core.select.residue_selector.ChainSelector('X')

    # User-defined design positions
    design_positions = [str(index) for index in design_json_info['design_residue_list']]
    design_position_rs = rosetta.core.select.residue_selector.ResidueIndexSelector(','.join(design_positions))

    # Packing shell around design/matched residues
    relevent_residue_rs = rosetta.core.select.residue_selector.OrResidueSelector()
    relevent_residue_rs.add_residue_selector(design_position_rs)

    # Matched motif residues
    matched_motif_residues = parse_matcher_remarks(match_path)
    if len(matched_motif_residues) > 0:
        matched_motif_rs = rosetta.core.select.residue_selector.ResidueIndexSelector(','.join([str(a) for a in matched_motif_residues]))
        relevent_residue_rs.add_residue_selector(matched_motif_rs)

    packing_shell_rs = rosetta.core.select.residue_selector.NeighborhoodResidueSelector(relevent_residue_rs, 8, include_focus_in_subset=True)

    # NATRO positions in pose
    natro_rs = rosetta.core.select.residue_selector.NotResidueSelector(packing_shell_rs)

    natro_or_designable_rs = rosetta.core.select.residue_selector.OrResidueSelector()
    natro_or_designable_rs.add_residue_selector(design_position_rs)
    natro_or_designable_rs.add_residue_selector(natro_rs)

    repack_only_rs = rosetta.core.select.residue_selector.NotResidueSelector(natro_or_designable_rs)

    # --- Create and Populate Task Factory --- #

    task_factory = rosetta.core.pack.task.TaskFactory()

    racaa = rosetta.core.pack.task.operation.RestrictAbsentCanonicalAASRLT()
    racaa.aas_to_keep('ADEFHIKLMNQRSTVWY')  # No CGP
    design_op = rosetta.core.pack.task.operation.OperateOnResidueSubset(racaa, design_position_rs)
    task_factory.push_back(design_op)

    repack_op = rosetta.core.pack.task.operation.OperateOnResidueSubset(rosetta.core.pack.task.operation.RestrictToRepackingRLT(), repack_only_rs)
    task_factory.push_back(repack_op)

    natro_op = rosetta.core.pack.task.operation.OperateOnResidueSubset(rosetta.core.pack.task.operation.PreventRepackingRLT(), natro_rs)
    task_factory.push_back(natro_op)

    fixed_ligand_op = rosetta.core.pack.task.operation.OperateOnResidueSubset(rosetta.core.pack.task.operation.PreventRepackingRLT(), matched_ligand_rs)
    task_factory.push_back(fixed_ligand_op)

    # Extra rotamers
    extra_rotamers_op = rosetta.core.pack.task.operation.ExtraRotamersGeneric()
    extra_rotamers_op.ex1(True)
    extra_rotamers_op.ex2(True)
    extra_rotamers_op.ex1_sample_level(rosetta.core.pack.task.ExtraRotSample.EX_ONE_STDDEV)
    extra_rotamers_op.ex2_sample_level(rosetta.core.pack.task.ExtraRotSample.EX_ONE_STDDEV)
    task_factory.push_back(extra_rotamers_op)

    # --- Create RotamerSets including fuzzball rotamers --- #

    rosetta.basic.options.set_boolean_option('packing:ex1', True)
    rosetta.basic.options.set_boolean_option('packing:ex2', True)
    rosetta.basic.options.set_boolean_option('packing:ex3', True)
    rosetta.basic.options.set_boolean_option('packing:ex4', True)
    rosetta.basic.options.set_integer_option('packing:ex1:level', 4)
    rosetta.basic.options.set_integer_option('packing:ex2:level', 4)
    rosetta.basic.options.set_integer_option('packing:ex3:level', 4)
    rosetta.basic.options.set_integer_option('packing:ex4:level', 4)

    if use_complementary_rotsets:
        viable_rotamers = generate_fuzzball_contact_rotamersets(ligand_conformer_path, match_path, match_pose, sfxn, match_residue_map,
                                                                flag_special_rot=True, rotset_limit=rotset_limit, apply_minimization=apply_minimization)

    # Turn off ex3 and ex4 after generating fuzzball contact rotamers
    rosetta.basic.options.set_boolean_option('packing:ex3', False)
    rosetta.basic.options.set_boolean_option('packing:ex4', False)
    # Reset ex1 and ex2 sampling level
    rosetta.basic.options.set_integer_option('packing:ex1:level', 1)
    rosetta.basic.options.set_integer_option('packing:ex2:level', 1)

    # --- Create and apply filters --- #

    # todo: this.

    # --- Perform Design --- #
    "Essentially pack_rotamers.cc"

    design_packer_task = task_factory.create_task_and_apply_taskoperations(match_pose)
    design_packer_task.or_linmem_ig(True)  # Linear memory Interaction Graph

    sfxn(match_pose)
    sfxn.setup_for_packing(match_pose, design_packer_task.repacking_residues(), design_packer_task.designing_residues())
    packer_neighbor_graph = rosetta.core.pack.create_packer_graph(match_pose, sfxn, design_packer_task)

    rotamer_sets = rosetta.core.pack.rotamer_set.RotamerSetsFactory.create_rotamer_sets(match_pose)
    rotamer_sets.set_task(design_packer_task)
    rotamer_sets.initialize_pose_for_rotsets_creation(match_pose)
    rotamer_sets.build_rotamers(match_pose, sfxn, packer_neighbor_graph)

    # DEBUGGING
    # pprint(viable_rotamers)
    # derp = pyrosetta.pose_from_sequence('A')
    # for position in viable_rotamers:
    #     for residuetype in viable_rotamers[position]:
    #         for res in viable_rotamers[position][residuetype]:
    #             derp.append_residue_by_jump(res, 1)
    # derp.dump_pdb('rotset.pdb')

    if use_complementary_rotsets:
        for position in viable_rotamers:
            if position in design_json_info['design_residue_list']:
                position_rotamer_set = rotamer_sets.rotamer_set_for_residue(position)

                # Add fuzzball rotamers to the appropriate rotamer_set in rotamer_sets
                if int(position_rotamer_set.resid()) == position:
                    for residue_type in viable_rotamers[position]:
                        print(f'Adding {len(viable_rotamers[position][residue_type])} {residue_type} rotamers at position {position}.')
                        for fuzz_rotamer in viable_rotamers[position][residue_type]:
                            position_rotamer_set.add_rotamer_into_existing_group(fuzz_rotamer)

    match_dir, match_filename = os.path.split(match_path)
    match_name = os.path.splitext(match_filename)[0]
    os.makedirs(designdir, exist_ok=True)

    for i in range(nstruct):
        design_pose = match_pose.clone()
        sfxn.setup_for_packing_with_rotsets(design_pose, rotamer_sets)
        rotamer_sets.prepare_sets_for_packing(design_pose, sfxn)
        ig = rosetta.core.pack.interaction_graph.InteractionGraphFactory.create_and_initialize_annealing_graph(design_packer_task, rotamer_sets, design_pose, sfxn, packer_neighbor_graph)
        rosetta.core.pack.pack_rotamers_run(design_pose, design_packer_task, rotamer_sets, ig)
        ig.clean_up_after_packing(design_pose)
        sfxn(design_pose)

        # --- Write design to file --- #
        design_pose.dump_pdb(os.path.join(designdir, f'{match_name}-{i}.pdb'))

# todo: add new energy method for applying bonus to flagged rotamer variants
# todo: figure out how to write a design guidance term using this implementation

# from rosetta.core.scoring.methods import ContextIndependentOneBodyEnergy
# @rosetta.EnergyMethod()
# class FuzzballDesignMethod(ContextIndependentOneBodyEnergy):
#     """
#     Bias design toward contacts observed in the fuzzball
#     """
#     def __init__(self):
#         ContextIndependentOneBodyEnergy.__init__(self, self.creator())
#
#     def residue_energy(self, res, pose, emap):
#         emap.get().set(self.scoreType, -1.0)