#!/usr/bin/env python3

import os
import sys
import copy
import json
import math
import pickle
from pprint import pprint

import prody
import pandas as pd
import numpy as np

from .motifs import Generate_Constraints
from .utils import *

import pyrosetta
from pyrosetta import rosetta

def generate_constrained_backrub_ensemble(raw_match_path, matcher_constraint):
    """
    Generate a backrub ensemble around the hypothetical binding site with matcher constraints applied
    :param raw_match_path: path to raw match output
    :param matcher_constraint: constraint file used to find match
    """
    pass


def parse_matcher_remarks(match_path):
    """
    Parse matcher remarks to return match positions

    :param match_pose: pose with matcher remark header
    :return:
    """

    motif_resnums = list()
    with open(match_path, 'r') as match:
        for line in match:
            split_remark = line.split()

            # Only parse matcher remarks
            if split_remark[0] == 'REMARK':
                if all([split_remark[:4] == ['REMARK', '666', 'MATCH', 'TEMPLATE'], split_remark[7:9] == ['MATCH', 'MOTIF']]):
                    motif_resnums.append(int(split_remark[11]))

    return motif_resnums

def generate_fuzzball_contact_rotamersets(ligand_conformer_path, match_path, match_pose, sfxn, match_residue_map,
                                          flag_special_rot=True, custom_taskop=None, rotset_limit=200,
                                          contact_method='RMSD', RMSD_limit=1.5, apply_minimization=False,
                                          dump_rotamerset_pdb=False, report_stats=False, defined_positions=None):
    """
    Generate rotamers that recapitulate observed fuzzball contacts for each position in a nucleated match

    :param ligand_conformer_path: path to ligand generated by molfile_to_params.py
    :param flag_special_rot: If true, flag rotamers as SPECIAL_ROT variants
    :param custom_taskop: list of task operations to apply to the PackerTask used to generate rotamers

    :return: viable_rotamers dictionary of rotamers organized by position and residue identity
    """

    sfxn_weights = sfxn.weights()
    conformer_resnum = match_pose.size()  # Assumes single ligand appended to end of sequence

    if contact_method not in ['RMSD', 'matcher']:
        raise Exception('Contact method needs to be one of the following: "RMSD", "matcher"')

    # --- Find and store viable rotamers --- #

    viable_rotamers = dict()
    rotamer_stats = dict()

    # Setting things up is going to mess up the match pose, so use a clone
    match_pose_clone = match_pose.clone()
    sfxn(match_pose_clone)

    # --- Transform match pose clone onto fuzzball conformer --- #
    """Required for contact coordsets to make sense"""

    # Get ligand from match, always last residue
    # todo: select chain X, ligand is always chain X
    match_pose_size = match_pose_clone.size()
    match_ligand = match_pose_clone.residue(match_pose_size)

    # Get match positions if they exist
    motif_resnums = list()
    with open(match_path, 'r') as my_match:
        for line in my_match:
            if line.startswith('REMARK 666 MATCH TEMPLATE'):
                motif_resnums.append(int(line.split()[11]))

    motif_and_ligand_resnums = motif_resnums + [conformer_resnum]

    # Keep track of match positions and compatible residue identites
    # match_residue_map = {position: dict() for position in range(1, match_pose.size())}  # Assumes one ligand appended to end of sequence

    # Import conformer from pose
    fuzzball_ligand_pose = rosetta.core.pose.Pose()
    rosetta.core.import_pose.pose_from_file(fuzzball_ligand_pose, ligand_conformer_path)
    fuzzball_ligand = fuzzball_ligand_pose.residue(1)

    # Calculate rotation/translation by hand using first three atoms of ligand
    mobile_match = rosetta.numeric.xyzTransform_double_t(match_ligand.xyz(1), match_ligand.xyz(2), match_ligand.xyz(3))
    mobile_match_inverse = mobile_match.inverse()
    target_fuzzball = rosetta.numeric.xyzTransform_double_t(fuzzball_ligand.xyz(1), fuzzball_ligand.xyz(2), fuzzball_ligand.xyz(3))

    ligand_rotation = target_fuzzball.R * mobile_match_inverse.R
    ligand_translation = target_fuzzball.R * mobile_match_inverse.t + target_fuzzball.t

    # Apply transformation
    match_pose_clone.apply_transform_Rx_plus_v(ligand_rotation, ligand_translation)
    match_pose_clone_ligand = match_pose_clone.residue(match_pose_size).clone()

    # --- All other operations --- #

    # Mutate all non-motif residues within 10A from ligand to ALA, interferes with RotamerSet generation
    ligand_residue_selector = rosetta.core.select.residue_selector.ChainSelector('X')
    neighborhood_selector = rosetta.core.select.residue_selector.NeighborhoodResidueSelector(ligand_residue_selector, 10, False)
    neighborhood_selector_bool = neighborhood_selector.apply(match_pose_clone)
    neighborhood_residues_resnums = rosetta.core.select.get_residues_from_subset(neighborhood_selector_bool)
    positions_to_consider = list(set(neighborhood_residues_resnums) - set(motif_and_ligand_resnums))

    mutate = rosetta.protocols.simple_moves.MutateResidue()
    mutate.set_res_name('ALA')

    for position in positions_to_consider:
        if match_pose_clone.residue(position).name3() not in ['GLY', 'PRO'] and 'disulfide' not in match_pose_clone.residue(position).name():
            mutate.set_target(position)
            mutate.apply(match_pose_clone)

    # Build RotamerSets for each extrachi/sample level
    if dump_rotamerset_pdb:
        all_rotamersets = rosetta.core.pack.rotamer_set.RotamerSetsFactory.create_rotamer_sets(match_pose_clone)
        task_factory = rosetta.core.pack.task.TaskFactory()

        # NATRO positions TaskOp
        rotamer_candidates_rs = rosetta.core.select.residue_selector.ResidueIndexSelector(','.join([str(i) for i in match_residue_map.keys()]))
        natro_rs = rosetta.core.select.residue_selector.NotResidueSelector(rotamer_candidates_rs)
        natro_op = rosetta.core.pack.task.operation.OperateOnResidueSubset(
            rosetta.core.pack.task.operation.PreventRepackingRLT(), natro_rs)
        task_factory.push_back(natro_op)

        rotamersets_packer_task = task_factory.create_task_and_apply_taskoperations(match_pose_clone)

        all_rotamersets.set_task(rotamersets_packer_task)

    # Remove ligand from match_pose_clone before generating rotamers!!!
    match_pose_clone_apo = match_pose_clone.clone()
    match_pose_clone_apo.conformation_ptr().delete_residue_slow(match_pose_size)

    # Define positions where rotamers will be considered

    if defined_positions:
        rotamerset_positions = list(set(defined_positions) & set(match_residue_map.keys()))
    else:
        rotamerset_positions = list(match_residue_map.keys())

    print(f'Rotamerset Positions: {rotamerset_positions}')

    # Generate rotamers at each position
    for position in rotamerset_positions:

        # Prepare minimization
        if apply_minimization:
            motif_movemap = rosetta.core.kinematics.MoveMap()
            motif_movemap.set_chi(position, True)

            minimize_motif = rosetta.protocols.minimization_packing.MinMover()
            minimize_motif.movemap(motif_movemap)
            minimize_motif.score_function(sfxn)
            minimize_motif.min_type('lbfgs_armijo')
            minimize_motif.tolerance(1e-6)

        # Prepare infrastructure
        rotamer_stats[position] = dict()

        if dump_rotamerset_pdb:
            current_rotamerset = rosetta.core.pack.rotamer_set.RotamerSetFactory.create_rotamer_set(match_pose_clone)

        # Keep rotamers that are compatible with minimal binding motif
        for contact_residue in match_residue_map[position]:

            # print(f'Considering position {position}: {contact_residue}')
            position_rotamer_list = list()
            possible_contact_geometries = match_residue_map[position][contact_residue]

            # --- Prepare viable rotamers for each position --- #

            # Define packertask using neighborhood_selector
            packer_task = rosetta.core.pack.task.TaskFactory.create_packer_task(match_pose_clone_apo)
            packer_task.initialize_from_command_line()

            # Get boolean vector for packable positions and apply to packer task
            packable_positions = rosetta.utility.vector1_bool()
            packable_position_list = [True if i == position else False for i in range(1, match_pose_clone_apo.size())]
            for bool_value in packable_position_list:
                packable_positions.append(bool_value)
            packer_task.restrict_to_residues(packable_positions)

            # Only build rotamers for residues with Hbond donors/acceptors
            restrict_CAAs = rosetta.core.pack.task.operation.RestrictAbsentCanonicalAAS(position, rosetta.utility.vector1_bool(20))
            restrict_CAAs.keep_aas(contact_residue)
            restrict_CAAs.apply(match_pose_clone_apo, packer_task)

            packer_neighbor_graph = rosetta.core.pack.create_packer_graph(match_pose_clone_apo, sfxn, packer_task)

            match_rotamer_set = rosetta.core.pack.rotamer_set.RotamerSetFactory.create_rotamer_set(match_pose_clone_apo)
            match_rotamer_set.set_resid(position)
            match_rotamer_set.build_rotamers(match_pose_clone_apo, sfxn, packer_task, packer_neighbor_graph, use_neighbor_context=False)

            if match_rotamer_set.num_rotamers() <= 1 and match_rotamer_set.rotamer(1).name1() != contact_residue:
                continue

            print(f'Position {position} ResidueType {contact_residue} - comparing {match_rotamer_set.num_rotamers()} rotamers against {len(possible_contact_geometries)} contact modes')

            rotamer_stats[position][contact_residue] = dict()
            rotamer_stats[position][contact_residue]['num_rotamers'] = match_rotamer_set.num_rotamers()
            rotamer_info = list()
            rotamers_accepted = 0

            # --- Evaluate Rotamers --- #

            for rotamer in range(1, match_rotamer_set.num_rotamers() + 1):

                # Place residue before applying to pose!!!!
                # Rotamers need to be transformed back onto the backbone of the input pdb!!!
                trail_rotamer = match_rotamer_set.rotamer(rotamer)
                trail_rotamer.place(match_pose_clone.residue(position), match_pose_clone.conformation_ptr())
                match_pose_clone.replace_residue(position, trail_rotamer, False)
                pose_trial_rotamer = match_pose_clone.residue(position)

                # Evaluate RMSD to possible_contact_geometries
                contact_RMSDs = list()
                dof_errors = list()
                sad_atom_in_rotamer = False

                for contact_mode in possible_contact_geometries:

                    # REFERENCE: contact_info = [current_motif_coord_list, [float(a) for a in dof_tuple], constraint_atoms_dict['residue']['atom_names'], constraint_atoms_dict['ligand']['atom_names']]
                    current_motif_coord_list = contact_mode[0]
                    contact_dofs = contact_mode[1]
                    residue_matchatoms = contact_mode[2]
                    ligand_matchatoms = contact_mode[3]

                    # Skip rotamer if contact is mediated by a backbone atom...
                    if residue_matchatoms[0] in ['C', 'CA', 'N', 'O']:
                        continue

                    # Get contact atom coords using atom names
                    try:
                        rotamer_contact_coords = [list(match_pose_clone.residue(position).xyz(atom)) for atom in residue_matchatoms]

                        # If distance is off, don't even bother...
                        residue_contactatom = pose_trial_rotamer.xyz(residue_matchatoms[0])
                        ligand_contactatom = match_pose_clone_ligand.xyz(ligand_matchatoms[0])
                        atom_displacement = ligand_contactatom - residue_contactatom
                        if atom_displacement.norm() > 4:
                            # print(f'Contact is {atom_displacement.norm()}A, continuing...')
                            continue

                        residue_atomid_list = [pose_trial_rotamer.xyz(atom) for atom in residue_matchatoms]
                        ligand_atomid_list = [match_pose_clone_ligand.xyz(atom) for atom in ligand_matchatoms]

                        # Res1 - ligand, Res2 - residue

                        # 'angle_A' is the angle Res1:Atom2 - Res1:Atom1 - Res2:Atom1
                        angle_A = rosetta.numeric.angle_degrees_double(ligand_atomid_list[1], ligand_atomid_list[0], residue_atomid_list[0])
                        # 'angle_B' is the angle Res1:Atom1 - Res2:Atom1 - Res2:Atom2
                        angle_B = rosetta.numeric.angle_degrees_double(ligand_atomid_list[0], residue_atomid_list[0], residue_atomid_list[1])
                        # 'torsion_A' is the dihedral Res1:Atom3 - Res1:Atom2 - Res1:Atom1 - Res2:Atom1
                        torsion_A = rosetta.numeric.dihedral_degrees_double(ligand_atomid_list[2], ligand_atomid_list[1], ligand_atomid_list[0], residue_atomid_list[0])
                        # 'torsion_AB' is the dihedral Res1:Atom2 - Res1:Atom1 - Res2:Atom1 - Res2:Atom2
                        torsion_AB = rosetta.numeric.dihedral_degrees_double(ligand_atomid_list[1], ligand_atomid_list[0], residue_atomid_list[0], residue_atomid_list[1])
                        # 'torsion_B' is the dihedral Res1:Atom1 - Res2:Atom1 - Res2:Atom2 - Res2:Atom3
                        torsion_B = rosetta.numeric.dihedral_degrees_double(ligand_atomid_list[0], residue_atomid_list[0], residue_atomid_list[1], residue_atomid_list[2])

                        rotamer_dofs = [angle_A, angle_B, torsion_A, torsion_AB, torsion_B]

                    except Exception as e:
                        print(e, residue_matchatoms, ligand_matchatoms)
                        # print(f'Skipping {contact_mode[0]}: contains sad atom.')
                        sad_atom_in_rotamer = True
                        break

                    # todo: Edge condition at 0/360...
                    dof_difference_list = [abs(ideal - measured) for ideal, measured in zip(contact_dofs[1:], rotamer_dofs)]
                    # print('contact_dofs:', contact_dofs)
                    # print('rotamer_dofs:', rotamer_dofs)
                    # print('DOF DIFFERENCE LIST:', dof_difference_list)
                    dof_errors.append(max(dof_difference_list))

                    contact_RMSDs.append(prody.calcRMSD(np.asarray(current_motif_coord_list), np.asarray(rotamer_contact_coords)))

                if len(dof_errors) == 0:
                    continue

                if sad_atom_in_rotamer:
                    continue

                # Continue if current rotamer does not have <{RMSD_limit}A RMSD with any contact mode
                if contact_method == 'RMSD' and min(contact_RMSDs, default=666) > RMSD_limit:
                    rotamer_info.append((contact_RMSDs, None, None))
                    continue

                # Only continue if a contact mode exists where max angle/torsion DOF error < 10 degrees
                if contact_method == 'matcher' and min(dof_errors) > 15:
                    continue

                # Apply minimization to rotamer-ligand interaction before deciding to accept
                if apply_minimization:
                    minimize_motif.apply(match_pose_clone)

                # Evaluate possible clashes (fa_rep) with motif residues and ligand
                sfxn(match_pose_clone)
                edges = match_pose_clone.energies().energy_graph()

                motif_fa_rep = list()
                for motif in motif_and_ligand_resnums:
                    current_edge = edges.find_energy_edge(position, motif)
                    if current_edge is not None:
                        current_edge.fill_energy_map()
                        motif_fa_rep.append(current_edge[rosetta.core.scoring.fa_rep])

                # Get score for current rotamer against ligand
                current_edge = edges.find_energy_edge(position, conformer_resnum)
                rotamer_ligand_reu = current_edge.dot(sfxn_weights) if current_edge is not None else 0

                if all([min(motif_fa_rep, default=666) < 20, rotamer_ligand_reu <= 20]):

                    if flag_special_rot:

                        current_rsd_type_ptr = match_pose_clone.residue_type_ptr(position)
                        new_rsd_type_mutable = rosetta.core.chemical.MutableResidueType(current_rsd_type_ptr)
                        new_rsd_type_mutable.add_variant_type(rosetta.core.chemical.SPECIAL_ROT)
                        new_rsd_type = rosetta.core.chemical.ResidueType.make(new_rsd_type_mutable)
                        rosetta.core.pose.replace_pose_residue_copying_existing_coordinates(match_pose_clone, position, new_rsd_type)

                    # Place residue before applying to pose!!!!
                    # Rotamers need to be transformed back onto the backbone of the input pdb!!!
                    new_rotamer = match_pose_clone.residue(position).clone()
                    new_rotamer.place(match_pose.residue(position), match_pose.conformation_ptr())

                    position_rotamer_list.append((rotamer_ligand_reu, new_rotamer))
                    rotamers_accepted += 1

                    if dump_rotamerset_pdb:
                        current_rotamerset.add_rotamer(new_rotamer)

                rotamer_info.append((max(dof_errors), max(motif_fa_rep, default=0), rotamer_ligand_reu))

            print(f'{rotamers_accepted} of {match_rotamer_set.num_rotamers()} rotamers accepted')
            rotamer_stats[position][contact_residue]['rotamer_info'] = rotamer_info
            rotamer_stats[position][contact_residue]['rotamers_accepted'] = rotamers_accepted

            if len(position_rotamer_list) > 0:
                position_rotamer_list_selected = sorted(position_rotamer_list, key=lambda x: x[0])[:rotset_limit]
                position_rotamer_list = [rot[1] for rot in position_rotamer_list_selected]
                if position not in viable_rotamers.keys():
                    viable_rotamers[position] = dict()
                viable_rotamers[position][contact_residue] = position_rotamer_list

        if dump_rotamerset_pdb:
            current_moltresid = all_rotamersets.resid_2_moltenres(position)
            all_rotamersets.set_explicit_rotamers(current_moltresid, current_rotamerset)

    if dump_rotamerset_pdb:
        current_extrachi = len([rosetta.basic.options.get_boolean_option(f'packing:ex{i}') for i in range(1,5) if rosetta.basic.options.get_boolean_option(f'packing:ex{i}') is True])
        current_sample_level = rosetta.basic.options.get_integer_option(f'packing:ex{current_extrachi}:level')

        if current_extrachi <= 2 and current_sample_level <= 3:
            match_name = os.path.normpath(os.path.basename(match_path))

            # todo: figure out why this doesn't work... problem with CONECT records...
            # all_rotamersets.dump_pdb(match_pose_clone, f"{match_name.split('.')[0]}-extrachi_{current_extrachi}-sampling_{current_sample_level}.pdb")

            all_rotamers_pose = pyrosetta.pose_from_sequence('A')

            for position in match_residue_map.keys():
                position_rotset = all_rotamersets.rotamer_set_for_residue(position)
                for rot in range(1, position_rotset.num_rotamers() + 1):
                    all_rotamers_pose.append_residue_by_jump(position_rotset.rotamer(rot), 1)
            all_rotamers_pose.dump_pdb(f"{match_name.split('.')[0]}-extrachi_{current_extrachi}-sampling_{current_sample_level}.pdb")

    if report_stats:
        return viable_rotamers, rotamer_stats
    else:
        return viable_rotamers


def create_task_factory(match_pose, match_path, return_rs=False):
    """
    Default task_factory for design from a given pose
    This assumes that the last residue of the pose is a ligand and that you are designing the context around the ligand
    All positions within 10A of the ligand with np.dot(CA->ligand_center, CA->CB) < 0 are designable
    All positions within clashbasedrepackshell of previous are designable
    All positions within clashbasedrepackshell of previous are repackable
    All other positions NATRO

    :param match_pose: Rosetta pose
    :return: task factory for match_pose
    """
    # --- Residue Selectors --- #

    # Ligand, ASSUMES SINGLE LIGAND AT END OF POSE!!!
    matched_ligand_rs = rosetta.core.select.residue_selector.ResidueIndexSelector(str(match_pose.size()))
    # matched_ligand_rs = rosetta.core.select.residue_selector.ChainSelector('X')

    # Loading params to PoseResidueTypeSet messes up ResidueType names -> selection with residue names...
    # match_ligand_name3 = match_pose.residue(match_pose.size()).name3()
    # matched_ligand_rs = rosetta.core.select.residue_selector.ResidueNameSelector(match_ligand_name3)

    # User-defined design positions
    # design_positions = [str(index) for index in design_json_info['design_residue_list']]
    # design_position_rs = rosetta.core.select.residue_selector.ResidueIndexSelector(','.join(design_positions))

    # NeighborhoodResidueSelector uses CB to determine distances, CA for GLY
    # All residues with CB within 10A of ligand
    ligand_neghborhood_rs = rosetta.core.select.residue_selector.NeighborhoodResidueSelector(matched_ligand_rs, 10, False)

    # All residues with np.dot(CA-CB vector, CA-ligand center) > 0
    ligand_facing_residues = list()
    for resnum in range(1, match_pose.size()):  # Assuming single ligand at end of sequence
        current_residue = match_pose.residue(resnum)
        if current_residue.name3() in ['GLY', 'CYS', 'PRO']: continue

        ca_cb_vector = current_residue.atom('CB').xyz() - current_residue.atom('CA').xyz()
        ca_center_vector = current_residue.nbr_atom_xyz() - current_residue.atom('CA').xyz()
        dot_product = ca_cb_vector.dot(ca_center_vector)
        if dot_product > 0:
            ligand_facing_residues.append(resnum)
    ligand_facing_residues_rs = rosetta.core.select.residue_selector.ResidueIndexSelector(
        ','.join([str(a) for a in ligand_facing_residues]))

    # First shell ligand contacts
    first_shell_rs = rosetta.core.select.residue_selector.AndResidueSelector()
    first_shell_rs.add_residue_selector(ligand_neghborhood_rs)
    first_shell_rs.add_residue_selector(ligand_facing_residues_rs)

    # ClashBasedRepackShell around first shell is designable
    second_shell_temp_rs = rosetta.core.pack.task.residue_selector.ClashBasedShellSelector(first_shell_rs)

    # Residue Selector for designable positions
    designable_residue_rs = rosetta.core.select.residue_selector.OrResidueSelector()
    designable_residue_rs.add_residue_selector(first_shell_rs)
    designable_residue_rs.add_residue_selector(second_shell_temp_rs)

    designable_residue_selection = designable_residue_rs.apply(match_pose)
    design_position_list = rosetta.core.select.get_residues_from_subset(designable_residue_selection)
    print('Designable Positions (pre-CPG filter):', design_position_list)

    # NATRO positions in pose
    relevant_positions_rs = rosetta.core.select.residue_selector.OrResidueSelector()

    # Matched motif residues
    matched_motif_residues = parse_matcher_remarks(match_path)
    if len(matched_motif_residues) > 0:
        # Remove match residues from designable positions
        design_position_list = set(design_position_list) - set(matched_motif_residues)
        # Update match and designable ResdiueSelectors
        matched_motif_rs = rosetta.core.select.residue_selector.ResidueIndexSelector(
            ','.join([str(a) for a in matched_motif_residues]))
        designable_residue_rs = rosetta.core.select.residue_selector.ResidueIndexSelector(
            ','.join([str(a) for a in design_position_list]))
        # Add match positions to relevant_residues_rs
        relevant_positions_rs.add_residue_selector(matched_motif_rs)

    # Packing shell around design/matched residues
    repack_shell_temp_rs = rosetta.core.pack.task.residue_selector.ClashBasedShellSelector(designable_residue_rs)
    repack_shell_selection = repack_shell_temp_rs.apply(match_pose)
    real_repack_positions = set(rosetta.core.select.get_residues_from_subset(repack_shell_selection)) - set(design_position_list)

    repack_position_list = [str(a) for a in (list(real_repack_positions) + matched_motif_residues)]
    add_repack_shell = True if len(repack_position_list) > 0 else False
    print('Repack Positions:', repack_position_list)

    if add_repack_shell:
        repack_shell_rs = rosetta.core.select.residue_selector.ResidueIndexSelector(','.join(repack_position_list))
        relevant_positions_rs.add_residue_selector(repack_shell_rs)

    relevant_positions_rs.add_residue_selector(designable_residue_rs)

    natro_rs = rosetta.core.select.residue_selector.NotResidueSelector(relevant_positions_rs)

    # Don't design CGP
    gly_rs = rosetta.core.select.residue_selector.ResidueNameSelector('GLY')
    cys_rs = rosetta.core.select.residue_selector.ResidueNameSelector('CYS')
    pro_rs = rosetta.core.select.residue_selector.ResidueNameSelector('PRO')
    cgp_rs = rosetta.core.select.residue_selector.OrResidueSelector()
    cgp_rs.add_residue_selector(gly_rs)
    cgp_rs.add_residue_selector(cys_rs)
    cgp_rs.add_residue_selector(pro_rs)

    # --- Create and Populate Task Factory --- #

    task_factory = rosetta.core.pack.task.TaskFactory()

    racaa = rosetta.core.pack.task.operation.RestrictAbsentCanonicalAASRLT()
    racaa.aas_to_keep('ADEFHIKLMNQRSTVWY')  # No CGP
    design_op = rosetta.core.pack.task.operation.OperateOnResidueSubset(racaa, designable_residue_rs)
    task_factory.push_back(design_op)

    if add_repack_shell:
        repack_op = rosetta.core.pack.task.operation.OperateOnResidueSubset(
            rosetta.core.pack.task.operation.RestrictToRepackingRLT(), repack_shell_rs)
        task_factory.push_back(repack_op)

    repack_cgp = rosetta.core.pack.task.operation.OperateOnResidueSubset(
        rosetta.core.pack.task.operation.RestrictToRepackingRLT(), cgp_rs)
    task_factory.push_back(repack_cgp)

    natro_op = rosetta.core.pack.task.operation.OperateOnResidueSubset(
        rosetta.core.pack.task.operation.PreventRepackingRLT(), natro_rs)
    task_factory.push_back(natro_op)

    fixed_ligand_op = rosetta.core.pack.task.operation.OperateOnResidueSubset(
        rosetta.core.pack.task.operation.PreventRepackingRLT(), matched_ligand_rs)
    task_factory.push_back(fixed_ligand_op)

    # Extra rotamers
    extra_rotamers_op = rosetta.core.pack.task.operation.ExtraRotamersGeneric()
    extra_rotamers_op.ex1(True)
    extra_rotamers_op.ex2(True)
    extra_rotamers_op.ex1_sample_level(rosetta.core.pack.task.ExtraRotSample.EX_ONE_STDDEV)
    extra_rotamers_op.ex2_sample_level(rosetta.core.pack.task.ExtraRotSample.EX_ONE_STDDEV)
    task_factory.push_back(extra_rotamers_op)

    if return_rs:
        return task_factory, relevant_positions_rs, matched_ligand_rs

    else:
        return task_factory


def fuzzball_composition_design(ligand_conformer_path, match_path, match_residue_map, params_path,
                                designdir='Designs', nstruct=1, special_rot_weight=-5, use_complementary_rotsets=True,
                                rotset_limit=50, rmsd=1.5, apply_minimization=False, dalphaball_path=None, match_cst=None):
    """
    Perform design using Vikram's AA_Composition score term, biasing toward rotamers that recapitulate contacts
    observed in the iteration fuzzball.

    :param dalphaball_path: If provided, use RosettaHoles filter with provided dalphaball.gcc
    :return:
    """

    # --- Initiate PyRosetta and Score Function -- #

    my_options = [f"-extra_res_fa {params_path}",
                  "-mute core.conformation core.chemical core.pack.task",
                  '-ex1 -ex2 -extrachi_cutoff 0 -use_input_sc',
                  '-run:preserve_header',
                  '-total_threads 1'  # This kills the cluster, fun times...
                  ]
    pyrosetta.init(options=' '.join(my_options))

    # Normal scorefunction for generating rotamers
    sfxn = rosetta.core.scoring.get_score_function()

    # Create match pose
    match_pose = rosetta.core.pose.Pose()
    rosetta.core.import_pose.pose_from_file(match_pose, os.path.join(os.getcwd(), match_path))

    # --- Create Task Factory --- #
    # Create task factory for unrelaxed, but apply to relaxed
    task_factory, relevant_positions_rs, matched_ligand_rs = create_task_factory(match_pose, match_path, return_rs=True)

    # Relax
    fast_relax = rosetta.protocols.relax.FastRelax(sfxn, 5, 'MonomerRelax2019')
    fast_relax.constrain_relax_to_native_coords(True)
    fast_relax.apply(match_pose)

    # Add defined_rotamer scoreterm
    sfxn.set_weight(rosetta.core.scoring.special_rot, special_rot_weight)

    # --- Set up Annealer for design --- #

    # Load viable scaffold positions and corresponding residue types
    # todo: make sure backrub ensemble structures also have matcher remarks added
    match_residue_map = pickle.load(open(match_residue_map, 'rb'))

    # --- Create Packer Task --- #
    design_packer_task = task_factory.create_task_and_apply_taskoperations(match_pose)
    design_packer_task.or_linmem_ig(True)  # Linear memory Interaction Graph
    print(design_packer_task)

    # coupeldmoves ligand ig edges reweight
    # core::pack::task::IGEdgeReweighterOP reweight_ligand(new protocols::toolbox::IGLigandDesignEdgeUpweighter(ligand_weight_) );
    # task->set_IGEdgeReweights()->add_reweighter(reweight_ligand);

    design_position_list = [index for index, res in enumerate(design_packer_task.designing_residues(), start=1) if res is True]
    print(f'Design positions: {design_position_list}')

    # --- Create RotamerSets including fuzzball rotamers --- #

    rosetta.basic.options.set_boolean_option('packing:ex1', True)
    rosetta.basic.options.set_boolean_option('packing:ex2', True)
    rosetta.basic.options.set_boolean_option('packing:ex3', True)  # Default level:1
    rosetta.basic.options.set_boolean_option('packing:ex4', True)  # Default level:1
    rosetta.basic.options.set_integer_option('packing:ex1:level', 4)
    rosetta.basic.options.set_integer_option('packing:ex2:level', 4)
    # rosetta.basic.options.set_integer_option('packing:ex3:level', 4)
    # rosetta.basic.options.set_integer_option('packing:ex4:level', 4)

    if use_complementary_rotsets:
        print("Generating complementrary RotamerSets...")
        viable_rotamers = generate_fuzzball_contact_rotamersets(ligand_conformer_path, match_path, match_pose, sfxn, match_residue_map,
                                                                flag_special_rot=True, rotset_limit=rotset_limit, RMSD_limit=rmsd,
                                                                apply_minimization=apply_minimization, defined_positions=design_position_list)

    # Turn off ex3 and ex4 after generating fuzzball contact rotamers
    rosetta.basic.options.set_boolean_option('packing:ex3', False)
    rosetta.basic.options.set_boolean_option('packing:ex4', False)
    # Reset ex1 and ex2 sampling level
    rosetta.basic.options.set_integer_option('packing:ex1:level', 1)
    rosetta.basic.options.set_integer_option('packing:ex2:level', 1)

    # --- Create filters --- #
    print("Creating Filters...")

    # Binding Strain
    binding_strain_filter = rosetta.protocols.protein_interface_design.filters.BindingStrainFilter()
    binding_strain_filter.threshold(9999)
    binding_strain_filter.scorefxn(sfxn)
    binding_strain_filter.task_factory(task_factory)
    binding_strain_filter.jump(match_pose.num_chains() - 1)  # Assumes ligand is at end of pose

    # DDG (BindingStrain seems to perform an equivalent operation)
    # <Ddg name="(ddg &string)" scorefxn="(score12 &string)" threshold="(-15 &float)" jump="(1 &Integer)" chain_num="(&int,&int...)" repeats="(1 &Integer)" repack="(true &bool)" relax_mover="(&string)" repack_bound="(true &bool)" repack_unbound="(true &bool)" relax_bound="(false &bool)" relax_unbound=("true &bool) filter="(&string)"/>

    # ShapeComplementarity
    shape_complementarity_filter = rosetta.protocols.simple_filters.ShapeComplementarityFilter()
    shape_complementarity_filter.filtered_sc(0)
    shape_complementarity_filter.filtered_area(0)
    shape_complementarity_filter.jump_id(match_pose.num_chains() - 1)
    shape_complementarity_filter.quick(0)
    shape_complementarity_filter.verbose(0)
    shape_complementarity_filter.write_int_area(1)

    # ResidueIE
    residueie_resnum = match_pose.size()  # Assumes ligand is last residue in Pose
    residueie_restype = match_pose.residue(residueie_resnum).name3()
    residueie_filter = rosetta.protocols.simple_filters.ResidueIEFilter(str(residueie_resnum), residueie_restype, sfxn, rosetta.core.scoring.total_score, 0, False, True, 1, 8, 0, 1, True)

    # PackStat
    packstat_filter = rosetta.protocols.simple_filters.PackStatFilter(0)

    # RosettaHoles (optional)
    if dalphaball_path:
        rosetta.basic.options.set_file_option('holes:dalphaball', dalphaball_path)

        relevant_positions_selection = relevant_positions_rs.apply(match_pose)
        relevant_positions_str_list = [str(a) for a in set(rosetta.core.select.get_residues_from_subset(relevant_positions_selection))]

        filters_xml = f'''
                        <SCOREFXNS>
                            <ScoreFunction name="sfxn" weights="ref2015"/>
                        </SCOREFXNS>

                        <RESIDUE_SELECTORS>
                            <Index name="relevant_positions" resnums="{','.join(relevant_positions_str_list)}"/>
                        </RESIDUE_SELECTORS>

                        <FILTERS>
                            <Holes name="holes_filter" threshold="1" residue_selector="relevant_positions" confidence="0"/>
                        </FILTERS>'''
        holes_filter = rosetta.protocols.rosetta_scripts.XmlObjects.create_from_string(filters_xml).get_filter("holes_filter")

    # Buried Unsats
    buried_unsat_filter = rosetta.protocols.simple_filters.BuriedUnsatHbondFilter()
    buried_unsat_filter.set_residue_selector(relevant_positions_rs)
    buried_unsat_filter.set_print_out_info_to_pdb(True)

    # SASAMetric
    sasa_metric = rosetta.core.simple_metrics.metrics.SasaMetric()
    sasa_metric.set_residue_selector(matched_ligand_rs)

    # --- Create Constraints --- #
    if match_cst:
        match_constraints = rosetta.protocols.enzdes.AddOrRemoveMatchCsts()
        match_constraints.cstfile(match_cst)

    # --- Perform Design --- #
    "Essentially pack_rotamers.cc"

    sfxn(match_pose)
    sfxn.setup_for_packing(match_pose, design_packer_task.repacking_residues(), design_packer_task.designing_residues())
    packer_neighbor_graph = rosetta.core.pack.create_packer_graph(match_pose, sfxn, design_packer_task)

    rotamer_sets = rosetta.core.pack.rotamer_set.RotamerSetsFactory.create_rotamer_sets(match_pose)
    rotamer_sets.set_task(design_packer_task)
    rotamer_sets.initialize_pose_for_rotsets_creation(match_pose)
    rotamer_sets.build_rotamers(match_pose, sfxn, packer_neighbor_graph)

    # DEBUGGING
    # pprint(viable_rotamers)
    # derp = pyrosetta.pose_from_sequence('A')
    # for position in viable_rotamers:
    #     for residuetype in viable_rotamers[position]:
    #         for res in viable_rotamers[position][residuetype]:
    #             derp.append_residue_by_jump(res, 1)
    # derp.dump_pdb('rotset.pdb')

    if use_complementary_rotsets:
        for position in viable_rotamers:
            if design_packer_task.design_residue(position):
                print(f"Adding complementary rotamers for position {position}")
                position_rotamer_set = rotamer_sets.rotamer_set_for_residue(position)

                # Add fuzzball rotamers to the appropriate rotamer_set in rotamer_sets
                if int(position_rotamer_set.resid()) == position:
                    for residue_type in viable_rotamers[position]:
                        print(f'Adding {len(viable_rotamers[position][residue_type])} {residue_type} rotamers at position {position}.')
                        for fuzz_rotamer in viable_rotamers[position][residue_type]:
                            position_rotamer_set.add_rotamer_into_existing_group(fuzz_rotamer)

    match_dir, match_filename = os.path.split(match_path)
    match_name = os.path.splitext(match_filename)[0]
    os.makedirs(designdir, exist_ok=True)

    list_of_dicts = list()

    for i in range(nstruct):
        design_pose = match_pose.clone()
        design_path = os.path.join(designdir, f'{match_name}-{i}.pdb')

        # Mutate all designable positions to alanine first
        # mutate = rosetta.protocols.simple_moves.MutateResidue()
        # mutate.set_res_name('ALA')
        # for position in design_position_list:
        #     mutate.set_target(position)
        #     mutate.apply(design_pose)

        # Apply match constraints
        if match_cst:
            # There's no way to set cst_instruction through a pure PyRosetta interface...
            add_match_cst_xml = f'''
                <SCOREFXNS>
                    <ScoreFunction name="sfxn" weights="ref2015"/>
                </SCOREFXNS>
                <MOVERS>
                    <AddOrRemoveMatchCsts cst_instruction="add_new" name="add_match_constraints"  cstfile="{match_cst}"/>
                </MOVERS>'''
            rosetta.protocols.rosetta_scripts.XmlObjects.create_from_string(add_match_cst_xml).get_mover("add_match_constraints").apply(design_pose)

        # Perform design
        sfxn.setup_for_packing_with_rotsets(design_pose, rotamer_sets)
        rotamer_sets.prepare_sets_for_packing(design_pose, sfxn)
        ig = rosetta.core.pack.interaction_graph.InteractionGraphFactory.create_and_initialize_annealing_graph(design_packer_task, rotamer_sets, design_pose, sfxn, packer_neighbor_graph)
        rosetta.core.pack.pack_rotamers_run(design_pose, design_packer_task, rotamer_sets, ig)
        ig.clean_up_after_packing(design_pose)
        sfxn(design_pose)

        # --- Apply Filters --- #

        bindingstrain = binding_strain_filter.compute(design_pose)
        binding_strain_remark = rosetta.core.io.RemarkInfo()
        binding_strain_remark.value = f'BindingStrain\t{bindingstrain}'

        shape_complementarity_filter.apply(design_pose)
        shapecomplementarity = shape_complementarity_filter.report_sm(design_pose)
        shape_complementarity_remark = rosetta.core.io.RemarkInfo()
        shape_complementarity_remark.value = f'ShapeComplementarity\t{shapecomplementarity}'

        residueie = residueie_filter.compute(design_pose)
        residueie_remark = rosetta.core.io.RemarkInfo()
        residueie_remark.value = f'ResidueIE\t{residueie}'

        packstat = packstat_filter.compute(design_pose)
        packstat_remark = rosetta.core.io.RemarkInfo()
        packstat_remark.value = f'Packstat\t{packstat}'

        heavyburiedunsats = buried_unsat_filter.compute(design_pose)
        heavyburiedunsats_remark = rosetta.core.io.RemarkInfo()
        heavyburiedunsats_remark.value = f'HeavyBuriedUnsats\t{heavyburiedunsats}'

        ligand_sasa = sasa_metric.calculate(design_pose)
        ligand_sasa_remark = rosetta.core.io.RemarkInfo()
        ligand_sasa_remark.value = f'LigandSASA\t{ligand_sasa}'

        if dalphaball_path:
            holes_value = holes_filter.report_sm(design_pose)
            print(f'HOLES (compute): {holes_value}')
        
        # Count hbonds to ligand
        pose_hbondset = design_pose.get_hbonds()
        ligand_position = design_pose.size()
        ligand_hbond_vector = pose_hbondset.residue_hbonds(ligand_position)  # Assumes ligand is last residue in pose!!!

        design_dict = {'path': design_path,
                       'match': match_name,
                       'bindingstrain': bindingstrain,
                       'shapecomplementarity': shapecomplementarity,
                       'residueie': residueie,
                       'packstat': packstat,
                       'heavyburiedunsats': heavyburiedunsats,
                       'ligand_sasa': ligand_sasa,
                       'hbonds': len(ligand_hbond_vector),
                       'comprotset': use_complementary_rotsets,
                       'special_rot_weight': special_rot_weight,
                       }

        if dalphaball_path:
            design_dict['holes'] = holes_value

        list_of_dicts.append(design_dict)

        # --- Add Remarks to PDB --- #
        # todo: figure out why bad_alloc is thrown here
        # design_pose.pdb_info().remarks().append(binding_strain_remark)
        # design_pose.pdb_info().remarks().append(shape_complementarity_remark)
        # design_pose.pdb_info().remarks().append(residueie_remark)
        # design_pose.pdb_info().remarks().pdb_info().remarks().append(packstat_remark)
        # design_pose.pdb_info().remarks().append(heavyburiedunsats_remark)
        # design_pose.pdb_info().remarks().append(ligand_sasa_remark)

        # --- Write design to file --- #
        design_pose.dump_pdb(design_path)

    return pd.DataFrame(list_of_dicts)
